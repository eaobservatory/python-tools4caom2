#!/usr/bin/env python
#/*+
#************************************************************************
#****  C A N A D I A N   A S T R O N O M Y   D A T A   C E N T R E  *****
#*
#* (c) 2013  .                      (c) 2013
#* National Research Council        Conseil national de recherches
#* Ottawa, Canada, K1A 0R6          Ottawa, Canada, K1A 0R6
#* All rights reserved              Tous droits reserves
#*
#* NRC disclaims any warranties,    Le CNRC denie toute garantie
#* expressed, implied, or statu-    enoncee, implicite ou legale,
#* tory, of any kind with respect   de quelque nature que se soit,
#* to the software, including       concernant le logiciel, y com-
#* without limitation any war-      pris sans restriction toute
#* ranty of merchantability or      garantie de valeur marchande
#* fitness for a particular pur-    ou de pertinence pour un usage
#* pose.  NRC shall not be liable   particulier.  Le CNRC ne
#* in any event for any damages,    pourra en aucun cas etre tenu
#* whether direct or indirect,      responsable de tout dommage,
#* special or general, consequen-   direct ou indirect, particul-
#* tial or incidental, arising      ier ou general, accessoire ou
#* from the use of the software.    fortuit, resultant de l'utili-
#*                                  sation du logiciel.
#*
#************************************************************************
#*
#*   Script Name:    dp_container.py
#*
#*   Purpose:
#*    Container class that holds a list of files to ingest that are
#*    referenced by their identity_instand_id in the data_proc tables
#*
#*   Modification History:
#*
#****  C A N A D I A N   A S T R O N O M Y   D A T A   C E N T R E  *****
#************************************************************************
#-*/

__author__ = "Russell O. Redman"

import commands
import os
import os.path
import re
import time

from tools4caom2 import __version__
from tools4caom2.basecontainer import basecontainer

__doc__ = """
The dataproc_container class holds a list of processed files to ingest that are
referenced by their identity_instance_id in the data_proc
dp_recipe_output table

Version: """ + __version__.version

class dataproc_container(basecontainer):
    def __init__(self, 
                 identity_instance_id, 
                 conn, 
                 working_directory, 
                 filterfunc):
        """
        A dataproc_container references the list of AD URIs generated by
        a recipe instance in the data_proc system running at the CADC.  To 
        use a dataproc_container, it is necessary to be able to connect to
        the data_proc database at the CADC.
        
        The recipe instance is identified  using the primary key
        identity_instance_id for the data_proc.dbo.dp_recipe_output table.
        This table contains a list of AD URIs with the format:
            "ad:[A-Z]+/(a-zA-Z.-_]+)"
        For example:
          ad:JCMT/jcmth20110811_00044_01_reduced001_nit_000
          ad:JCMT/jcmth20110811_00044_01_rsp_nit_000
        URIs found in the table will be checked to verify that the 
        file exists in AD before the file_id is added to the filedict.

        The list is valid only if the state of the recipe instance from the
        field dp_recipe_instance.dbo.state (also keyed using
        identity_instance_id) has the value "Y", indicating successful
        completion of the last run of the recipe instance.  An exception
        will be raised if any other state is encountered.
        
        The files will be extracted from AD into working_directory and after
        use will be deleted again.
        
        Arguments:
        identity_instance_id: a string providing the primary key for the 
                              db_recipe_output table
        conn: a connection to the database
        working_directory: path to the working directory where temporary 
                           files can be created
        filterfunc: returns True if filename should be ingested
        """
        basecontainer.__init__(self, 'dp_' + identity_instance_id)

        if os.path.isdir(working_directory):
            self.directory = os.path.abspath(working_directory)
        else:
            raise basecontainer.ContainerError('ERROR: not a directory: ' +
                                               working_directory)

        if not conn:
            raise basecontainer.ContainerError('ERROR: no connection to the '
                                               'database')

        self.ad_uri = {}

        sqlcmd = '\n'.join([
            'SELECT state',
            'FROM data_proc.dbo.dp_recipe_instance',
            'WHERE identity_instance_id=' + identity_instance_id])
        result = conn.read(sqlcmd)
        
        if result:
            dp_state = result[0][0]
            if dp_state != 'Y':
                raise basecontainer.ContainerError('ERROR: state of '
                    'indentity_instance_id is "' + dp_state + 
                    '" but must be "Y: for ingestion to proceed') 

        sqlcmd = '\n'.join([
            'SELECT dp_output',
            'FROM data_proc.dbo.dp_recipe_output',
            'WHERE identity_instance_id=' + identity_instance_id])
        result = conn.read(sqlcmd)
        
        if result:
            filecount = 0
            for aduri, in result:
                match = re.search(r'ad:([A-Z]+)/([a-zA-Z0-9.\-_]+)',
                                 aduri)
                if match:
                    (archive, file_id) = match.group(1, 2)
                    # Beware that uri's from dp_recipe_output include extensions
                    file_id = os.path.splitext(file_id)[0]
                    
                    cmd = 'adInfo -a %s -q -fileName %s' % \
                          (archive, file_id)

                    # work-around for adInfo bug - retry up to 3 times with
                    # increasing delays
                    numtries = 0
                    status = 1
                    while numtries < 3 and status:
                        status, adfilename = commands.getstatusoutput(cmd)
                        if status:
                            numtries += 1
                            time.sleep(1.0 * numtries)
                    
                    if status:
                        # file not found error for adInfo
                        # ignore these errors and skip the files because they
                        # failed ingestion into AD
                        if status != 1280:
                            raise basecontainer.ContainerError(
                                'adInfo fails for %s in %s with status=%d'
                                ' after %d tries' %
                                (file_id, adfilename, status, numtries))
                    if not filterfunc or filterfunc(adfilename):
                        self.filedict[file_id] = \
                            os.path.join(self.directory, adfilename)
                        self.ad_uri[file_id] = archive

                        filecount += 1
            if filecount == 0:
                raise basecontainer.ContainerError(
                        'ERROR: identity_instance_id ' + identity_instance_id + 
                        ' contains no valid ad URIs')

    def get(self, file_id):
        """
        Fetch a file from ad into the working directory

        Arguments:
        file_id : The file_id to extract from the archive
        """
        if file_id not in self.ad_uri:
            raise basecontainer.ContainerError('ERROR: ' + file_id +
                                               ' not in ' +
                                               repr(self.file_id_list()))

        cmd = 'cd %s ; adGet -a %s %s' % (self.directory,
                                          self.ad_uri[file_id],
                                          file_id)

        status, output = commands.getstatusoutput(cmd)
        if status:
            raise basecontainer.ContainerError('ERROR: ' + cmd +
                                               ' returned: "' + output + '"')
        return self.filedict[file_id]

    def cleanup(self, file_id):
        """
        Clean up deleted the file from the working directory

        Arguments:
        file_id : file_id of the file to delete
        """
        os.remove(self.filedict[file_id])
